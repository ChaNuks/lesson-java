### 1. Method 패키지에 Main 클래스를 만들고 "Hello World" 를 5번 출력하는 메서드를 만들어보세요
~~~
 - 작성 완료
~~~
--- 
### 2. 객체지향이 담긴 의미를 설명해보세요
~~~
1. 클래스와 객체
- 클래스는 객체를 생성하기 위한 템플릿 (속성과 동작)
- 객체는 클래스의 인스턴스, 실제로 메모리에 할당된 구체적인 데이터

2. 캡슐화
- 객체의 데이터를 외부에서 직접 접근하기 못하게 한다.
- 메서드를 통해서만 접근할 수 있다.
- 이를 통해 데이터의 무결성을 보호 및 객체 내부의 구현 세부 사항을 숨김

3. 상속
- 새로운 클래스가 기존 클래스의 특성과 행동을 물려받는 것
- 재사용성과 확장성을 높여 코드의 중복을 줄이고, 더 쉽게 요지보수 가능

4. 다형성
- 동일한 메서드나 연산자가 서로 다른 객체에서 다르게 동작하는 것
- 오버로딩과 오버라이딩을 통해 구현
- 오버로딩 : 같은 이름의 메서드를 매개변수의 유형이나 개수에 따라 여러 개를 정의
- 오버라이딩 : 상속받은 메서드를 자식 클래스에서 재정의

5. 추상화
- 복잡한 시스템으로부터 주요 개념이나 기능을 추려내어 간단히 표현한 것
- 추상클래스와 인터페이스를 통해 구현
- 공통된 속성과 메서드를 정의하고, 인터페이스는 클래스가 구현해야 하는 메서드의 집합을 정의

~~~
--- 

### 3. Object 클래스에 대해 설명해보세요
~~~
- 자바 언어의 모든 클래스의 최상위 클래스
- 모든 클래스는 명시적으로 상속하지 않더라도 'Object' 클래스를 상속 받는다.
~~~
---

### 4. 캡슐화에 대해 설명해보세요
~~~ 
- 객체의 데이터를 외부에서 직접 접근하기 못하게 한다.
- 메서드를 통해서만 접근할 수 있다.
- 이를 통해 데이터의 무결성을 보호 및 객체 내부의 구현 세부 사항을 숨긴다.
~~~
--- 

### 5. modifier 패키지에 4가지 접근제어자를 사용하여 접근 가능한 경우 불가능한 경우를 자유롭게 만들고 설명해보세요  
~~~
- 예제 완료
~~~
--- 

### 6. 클래스를 만들고 객체를 생성했을때와 main 메서드에서 기본형 변수를 사용했을때 각각 어느 메모리 영역에 저장되는지 설명해 보세요 
~~~

public class Main {
    public static void main(String[] args) {
        int price = 10000;
        String name = "김철수"
        Owner owner = new Owner("김철수")
        Hotel hotel = new Hotel(price, owner);
    }
}

- price는 기본형 데이터 타입인 int로 선언, 기본형 변수는 스택 메모리에 저장

- name 변수 자체는 스택 메모리에 저장되지만, "김철수" 문자열 리터럴은 힘 메모리의 상수 풀 영역을 참조

- Owner와 Hotel 객체는 힙 메모리 영역에 저장
- owner와 hotel 변수 자체는 스택 메모리에 저장되며, 힙 메모리에 있는 실제 객체를 참조
~~~
---

### 7. constructor 패키지에 기본생성자 생략한 것과 생략하지 않은 클래스를 만들어보고 생성자의 역할에 대해 설명해보세요
~~~
- 생성자는 객체 생성 시 필요한 초기화 작업을 해주는 것
- 생성자 오버로딩을 통해 다양한 방식으로 객체를 초기화 함

1. 기본 생성자 O
- 매개변수를 받지 않음
- 인스턴스를 생성할 때 기본값으로 필드를 초기화
- 클래스에 아무런 생성자도 정의하지 않으면 컴파일러가 자동으로 추가

2. 기본 생성자 X
- 반대로 생성자 정의하지 않으면 자동으로 추가 안 됨
- 객체를 생성할 때 반드시 매개변수가 있는 생성자를 사용해야 함

즉, 기본 생성자가 있으면 매개변수 없이 객체를 생성 가능
    기본 생성자가 없으면 매개변수를 넣어서 객체를 생성
    
- 예제 완료
~~~

--- 
### 8. 객체지향 5가지 원칙에 대해 설명하고 위반한 예제를 만들어보고 그에 따른 준수 예제로 만들어보세요(solid 패키지)
~~~
1. SRP (단일 책임의 원칙)
- 클래스는 단 하나의 책임을 가져야 한다.
- ex) Employee 클래스는 직원의 정보를 관리하는 책임만, Pay 클래스는 급여를 계산하는 책임만 가진다.

2. OCP (개방-폐쇄 원칙)
- 소프트웨어 요소는 확장에는 열려 있어야 하고, 수정에는 닫혀 있어야 한다.
- 즉, 새로운 기능을 추가할 때 기존 코드를 변경하지 않고 확장할 수 있어야 한다.
- ex) 인터페이스 or 상속을 통해 기존 클래스를 확장하는 방식

3. LSP (리스코프 치환 원칙)
- 상위 클래스 객체 대신 하위 클래스 객체를 사용해서 프로그램은 정상적으로 동작해야 한다.
- ex) Rectangle 클래스가 있고 이를 상속받은 Square 클래스가 있을 때, Square은 Rectangle 클래스의 모든 속성을 유지하면서도 추가적인 제약(정사각형 특성)을 가질 수 있어야 한다.

4. ISP (인터페이스 분리 원칙)
- 여러 기능을 가진 하나의 인터페이스 대신, 각 기능별로 인터페이스를 분리하여 필요한 기능만을 구현하도록 한다.

5. DIP (의존 역전 원칙)
- 고수준 모듈은 저수준 모듈에 의존해선 X
- 둘 다 추상화에 의존해야 한다.
- 즉, 클래스가 직접 서로를 참조하기보단 인터페이스나 추상 클래스를 통해 참조하도록 한다.
- 결합도를 낮추고 응집도를 높인다.

- 예제 진행 중
~~~
---

### 9. 다형성 관련된 예제를 만들어보세요 (polymorphism 패키지)
~~~
- 작성 완료
~~~
---

### 10. enum에 장단점을 작성해보세요
~~~
- 열거형, 상수 집합을 정의하는 클래스

- 장점
1. 타입 안정성 : 컴파일 시 타입 체크가 이루어져 잘못된 값을 사용할 수 없게 한다.
2. 가독성 : 코드의 의도를 명확하게 표현
3. 안전함 : 값이 변경될 가능성이 없어 안전
4. 조직화 : 관련된 상수들을 하나의 enum으로 묶어 조직화
5. 내장 메서드 기능 제공 : name(), ordinal(), values() 등을 제공하여 상수의 이름, 순서, 모든 값을 쉽게 다룸

- 단점
1. 메모리 사용 : 내부적인 클래스로 구현되므로, 단순한 정수, 문자열, 상수보다 더 많은 메모리 사용
2. 유연성 부족 : 컴파일 시 고정되므로 런타임에 동적으로 추가하거나 변경할 수 없음
3. 상속 제한 : 다른 클래스를 상속받을 수 없고, enum 자체도 상속될 수 없다. 단, 인터페이스는 구현 가능
4. 비교의 제한 : enum 상수는 == 연산자로 비교해야 하며, 상수의 순서를 기반으로 비교하는 것은 ordinal()을 사용해야만 한다. 
~~~
---

### 11. 추상화에 대해 설명해보세요
~~~
- 복잡한 시스템으로부터 주요 개념이나 기능을 추려내어 간단히 표현한 것
- 추상클래스와 인터페이스를 통해 구현
- 공통된 속성과 메서드를 정의하고, 인터페이스는 클래스가 구현해야 하는 메서드의 집합을 정의
~~~
---

